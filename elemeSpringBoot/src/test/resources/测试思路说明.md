# 单元测试设计思路说明

## 概述

本文档详细说明了饿了么外卖系统单元测试的设计思路，包括每个测试文件的测试目标、测试策略和具体实现方法。

---

## 1. ValidationUtilsTest.java - 验证工具类测试

### 🎯 测试目标
测试系统核心的数据验证逻辑，确保所有输入数据都能被正确验证。

### 💡 测试思路
采用**黑盒测试**方法，重点使用：
- **边界值分析**：测试输入数据的边界情况
- **等价类划分**：将输入数据分为有效和无效两大类

### 🧪 主要测试场景

#### 手机号验证测试
```java
// 测试思路：测试11位手机号的边界情况
- 10位数字 → 应该失败（长度不足）
- 11位有效手机号 → 应该成功
- 12位数字 → 应该失败（长度超出）
- 包含字母的11位 → 应该失败（格式错误）
```

#### 密码验证测试
```java
// 测试思路：测试密码复杂度和长度
- 5位密码 → 失败（太短）
- 6位字母+数字 → 成功（最小有效长度）
- 20位字母+数字 → 成功（最大有效长度）
- 21位密码 → 失败（太长）
- 纯数字/纯字母 → 失败（复杂度不够）
```

#### 邮箱验证测试
```java
// 测试思路：测试邮箱格式和长度
- 4字符邮箱 → 失败（太短）
- 5字符有效邮箱 → 成功
- 100字符邮箱 → 成功（边界值）
- 101字符邮箱 → 失败（太长）
- 无@符号 → 失败（格式错误）
```

### 🔍 测试方法特点
- **嵌套测试类**：使用`@Nested`将相关测试分组
- **参数化测试**：使用数组循环测试多个数据
- **中文描述**：使用`@DisplayName`提供清晰的测试说明

---

## 2. EmailServiceTest.java - 邮件服务测试

### 🎯 测试目标
测试邮件发送和验证码功能，确保邮件服务稳定可靠。

### 💡 测试思路
采用**Mock测试**策略：
- **隔离外部依赖**：Mock掉真实的邮件发送服务
- **测试业务逻辑**：重点测试验证码生成和验证逻辑
- **异常场景测试**：测试邮件发送失败的处理

### 🧪 主要测试场景

#### 发送验证码测试
```java
// 测试思路：验证邮件发送的各种情况
✅ 正常邮箱 → 成功发送
❌ 空邮箱 → 抛出异常
❌ null邮箱 → 抛出异常
❌ 邮件服务故障 → 处理异常
```

#### 验证码验证测试
```java
// 测试思路：测试验证码的验证逻辑
✅ 正确验证码 → 验证成功
❌ 错误验证码 → 验证失败
❌ 不存在的邮箱 → 验证失败
❌ 过期验证码 → 验证失败（通过时间模拟）
```

#### 并发测试
```java
// 测试思路：测试多用户同时发送验证码
- 同时为多个邮箱发送验证码
- 验证验证码不会互相干扰
- 测试线程安全性
```

### 🔍 测试方法特点
- **Mock注解**：使用`@Mock`和`@InjectMocks`
- **行为验证**：使用`verify()`验证方法调用
- **异常测试**：使用`assertThrows()`测试异常情况

---

## 3. UserTest.java - 用户实体测试

### 🎯 测试目标
测试用户实体类的验证注解，确保数据约束正确工作。

### 💡 测试思路
采用**约束验证测试**：
- **Jakarta Validation**：测试实体类上的验证注解
- **Bean Validation**：验证对象属性的约束
- **组合验证**：测试多个字段组合的验证效果

### 🧪 主要测试场景

#### 单字段验证
```java
// 测试思路：逐个测试每个字段的约束
手机号字段：
- @NotBlank 注解 → 测试空值
- @Pattern 注解 → 测试格式
- 长度约束 → 测试边界值

密码字段：
- @NotBlank → 测试空值
- @Length → 测试长度范围
- @Pattern → 测试复杂度要求
```

#### 整体对象验证
```java
// 测试思路：创建完整用户对象进行验证
✅ 所有字段都有效 → 验证通过
❌ 任一字段无效 → 验证失败
❌ 多个字段无效 → 返回多个错误
```

#### 对象相等性测试
```java
// 测试思路：测试Lombok生成的equals和hashCode
- 相同内容的对象应该相等
- 不同内容的对象应该不相等
- 相等对象的hashCode应该相同
```

### 🔍 测试方法特点
- **验证器使用**：使用`Validator`接口进行验证
- **约束违反检查**：检查`ConstraintViolation`集合
- **错误消息验证**：验证错误消息的内容

---

## 4. UserControllerTest.java - 用户控制器测试

### 🎯 测试目标
测试用户相关的REST API接口，确保Web层功能正常。

### 💡 测试思路
采用**Web层测试**策略：
- **MockMvc测试**：模拟HTTP请求和响应
- **依赖Mock**：Mock掉Service层依赖
- **JSON序列化**：测试请求和响应的JSON格式

### 🧪 主要测试场景

#### 用户登录接口测试
```java
// 测试思路：测试POST /user/login接口
✅ 正确用户名密码 → 返回200，包含token和用户信息
❌ 错误密码 → 返回401，错误消息
❌ 缺少参数 → 返回400，参数错误
❌ 服务异常 → 返回500，服务器错误
```

#### 发送验证码接口测试
```java
// 测试思路：测试POST /user/sendVerifyCode接口
✅ 有效邮箱 → 返回200，"验证码已发送"
❌ 空邮箱 → 返回400，"邮箱不能为空"
❌ 邮件服务故障 → 返回500，"发送验证码失败"
```

#### 用户注册接口测试
```java
// 测试思路：测试POST /user/register接口
✅ 有效数据+正确验证码 → 返回200，注册成功
❌ 错误验证码 → 返回200，返回-1
❌ 用户已存在 → 返回200，返回0
```

### 🔍 测试方法特点
- **@WebMvcTest**：只加载Web层组件
- **MockMvc**：模拟HTTP请求
- **JSON断言**：使用`jsonPath()`验证响应

---

## 5. IntegrationTest.java - 集成测试

### 🎯 测试目标
测试各个组件之间的协作，验证完整的业务流程。

### 💡 测试思路
采用**端到端测试**策略：
- **组件协作**：测试多个组件一起工作
- **业务流程**：测试完整的用户操作流程
- **数据流转**：验证数据在各层之间正确传递

### 🧪 主要测试场景

#### 用户注册流程测试
```java
// 测试思路：模拟用户完整注册过程
1. 验证手机号格式 → ValidationUtils
2. 验证密码强度 → ValidationUtils
3. 验证邮箱格式 → ValidationUtils
4. 验证用户名 → ValidationUtils
5. 创建用户对象 → User Entity
6. 验证整个对象 → Jakarta Validation
```

#### 边界值集成测试
```java
// 测试思路：测试各种边界值的组合
- 所有字段都在边界值上的组合
- 有效边界值的组合应该通过
- 无效边界值的组合应该失败
```

#### 异常处理集成测试
```java
// 测试思路：测试系统的异常处理能力
- 空值处理
- 格式错误处理
- 边界值超出处理
- 多种错误的组合处理
```

### 🔍 测试方法特点
- **顺序执行**：使用`@Order`控制测试顺序
- **流程完整**：每个测试覆盖完整的业务流程
- **真实场景**：尽可能模拟真实用户操作

---

## 6. PerformanceTest.java - 性能测试

### 🎯 测试目标
测试系统的性能表现，确保在高负载下仍能稳定运行。

### 💡 测试思路
采用**负载测试**策略：
- **响应时间测试**：测试方法执行耗时
- **并发测试**：测试多线程并发执行
- **内存测试**：监控内存使用情况
- **压力测试**：测试系统在高负载下的表现

### 🧪 主要测试场景

#### 单一验证性能测试
```java
// 测试思路：测试单个验证方法的性能
for (int i = 0; i < 10000; i++) {
    ValidationUtils.validatePhoneNumber(phoneNumber);
}
// 统计总耗时和平均耗时
// 断言：平均耗时应该小于预期值
```

#### 并发性能测试
```java
// 测试思路：测试多线程并发验证
- 创建10个线程
- 每个线程执行1000次验证
- 统计总耗时
- 验证并发性能不会严重下降
```

#### 内存使用测试
```java
// 测试思路：监控内存使用情况
1. 记录初始内存使用
2. 执行大量验证操作
3. 记录最终内存使用
4. 验证内存增长在合理范围内
```

#### 批量验证测试
```java
// 测试思路：测试批量数据验证性能
- 准备多组测试数据
- 批量执行所有验证方法
- 统计批量处理的性能
```

### 🔍 测试方法特点
- **@Timeout**：设置测试超时时间
- **@RepeatedTest**：重复执行测试
- **性能断言**：验证性能指标
- **资源监控**：监控CPU和内存使用

---

## 测试策略总结

### 🎯 测试金字塔
```
        /\
       /  \
      /E2E \     ← IntegrationTest (少量)
     /______\
    /        \
   /   API    \   ← UserControllerTest (适量)
  /____________\
 /              \
/     Unit       \ ← ValidationUtilsTest, EmailServiceTest, 
\_________________/   UserTest, PerformanceTest (大量)
```

### 📊 测试覆盖率目标
- **单元测试**：覆盖所有核心业务逻辑
- **集成测试**：覆盖关键业务流程
- **性能测试**：覆盖高频使用的功能
- **API测试**：覆盖所有对外接口

### 🔧 测试工具选择
- **JUnit 5**：现代化的测试框架
- **Mockito**：强大的Mock框架
- **Spring Boot Test**：Spring应用测试支持
- **Jakarta Validation**：标准的验证框架

### 📈 测试质量保证
- **可读性**：中文描述，清晰的测试名称
- **可维护性**：合理的测试结构，避免重复代码
- **可靠性**：稳定的测试，不依赖外部环境
- **完整性**：覆盖正常和异常场景

---

## 7. CartControllerTest.java - 购物车控制器测试

### 🎯 测试目标
测试购物车相关的REST API接口，确保购物车功能正常运行。

### 💡 测试思路
采用**Web层测试**策略，特别关注Lombok问题：
- **避免setter方法**：使用Map传递数据，避免Lombok导致的setter问题
- **完整错误码覆盖**：测试所有可能的业务错误码
- **边界值测试**：重点测试数量、价格、容量限制

### 🧪 主要测试场景

#### 添加商品到购物车测试
```java
// 测试思路：测试POST /cart/add接口的各种情况
✅ 有效商品数据 → 返回200，code=200，"添加成功"
❌ 商品信息无效 → 返回400，code=400，"商品信息无效"
❌ 用户信息无效 → 返回400，code=400，"用户信息无效"
❌ 数量超限(>999) → 返回400，code=400，"商品数量超出限制(1-999)"
❌ 价格超限(>9999.99) → 返回400，code=400，"商品价格超出限制(0.01-9999.99)"
❌ 购物车已满 → 返回429，code=429，"购物车商品种类已达上限(50种)"
```

#### 更新购物车数量测试
```java
// 测试思路：测试PUT /cart/update/{itemId}接口
✅ 有效ID和数量 → 返回200，"更新成功"
❌ 无效ID(≤0) → 返回400，"商品ID无效"
❌ 商品不存在 → 返回404，"商品不存在"
❌ 商品已失效 → 返回410，"商品已失效"
```

### 🔍 Lombok问题解决方案
由于CartItem实体使用Lombok，我们采用Map方式传递数据：
```java
Map<String, Object> cartItemData = new HashMap<>();
cartItemData.put("userPhone", "13812345678");
cartItemData.put("foodId", 1);
cartItemData.put("quantity", 2);
cartItemData.put("price", 25.50);
```

---

## 8. FoodControllerTest.java - 商品控制器测试

### 🎯 测试目标
测试商品查询相关的REST API接口，确保商品数据正确返回。

### 💡 测试思路
采用**批量查询优化**策略：
- **批量ID查询**：测试根据ID列表获取多个商品
- **单品查询**：测试根据单个ID获取商品详情
- **边界值分析**：重点测试空列表、大量ID、重复ID等情况

### 🧪 主要测试场景

#### 批量获取商品测试
```java
// 测试思路：测试POST /food/getAllByIds接口
✅ 有效ID列表 → 返回200，商品数组
❌ 空结果 → 返回204 No Content
✅ 单个ID → 返回200，单个商品数组
✅ 重复ID → 返回200，去重后的商品列表
✅ 包含负数ID → 返回204，过滤无效ID
```

#### 单个商品查询测试
```java
// 测试思路：测试POST /food/getFoodById接口
✅ 有效ID → 返回200，商品详情
❌ 不存在ID → 返回404 Not Found
❌ ID为空 → 返回400 Bad Request
❌ 负数ID → 返回404 Not Found
```

### 🔍 反射处理Lombok问题
```java
private Food createMockFood(Integer id, String name, Double price) {
    Food food = new Food();
    try {
        java.lang.reflect.Field idField = Food.class.getDeclaredField("id");
        idField.setAccessible(true);
        idField.set(food, id);
        // ... 其他字段设置
    } catch (Exception e) {
        // 处理反射异常
    }
    return food;
}
```

---

## 9. BusinessControllerTest.java - 商家控制器测试

### 🎯 测试目标
测试商家信息查询接口，验证商家数据的正确性。

### 💡 测试思路
采用**自定义响应对象**测试策略：
- **BusinessResponse测试**：验证成功/失败响应格式
- **优惠信息处理**：测试setDiscounts方法调用
- **批量商家查询**：测试获取所有商家列表

### 🧪 主要测试场景

#### 获取所有商家测试
```java
// 测试思路：测试POST /business/getAll接口
✅ 有商家数据 → 返回200，商家数组
❌ 空数据 → 返回204 No Content
❌ null数据 → 返回204 No Content
✅ 单个商家 → 返回200，单个商家数组
```

#### 根据ID获取商家测试
```java
// 测试思路：测试POST /business/getBusinessById接口
✅ 有效ID → 返回200，{success: true, data: 商家信息}
❌ 不存在ID → 返回200，{success: false}
❌ 无效ID → 返回200，{success: false}
```

### 🔍 BusinessResponse格式验证
```java
mockMvc.perform(post("/business/getBusinessById")
        .contentType(MediaType.APPLICATION_JSON)
        .content(objectMapper.writeValueAsString(requestData)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.success").value(true))
        .andExpect(jsonPath("$.data.id").value(1));
```

---

## 10. OrderControllerTest.java - 订单控制器测试

### 🎯 测试目标
测试订单相关的所有功能，包括订单创建、查询、状态更新等。

### 💡 测试思路
采用**完整订单生命周期**测试策略：
- **订单CRUD操作**：创建、查询、更新订单
- **支付状态管理**：测试支付状态查询和更新
- **用户订单历史**：测试用户订单列表查询
- **订单详情查询**：测试订单详细信息获取

### 🧪 主要测试场景

#### 订单查询测试
```java
// 测试思路：测试POST /order/getUserOrderById接口
✅ 有效订单ID → 返回200，订单详情
❌ 不存在ID → 返回404 Not Found
❌ ID为空 → 返回400 Bad Request
❌ 负数/0 ID → 返回404 Not Found
```

#### 创建订单测试
```java
// 测试思路：测试POST /order/addUserOrder接口
✅ 有效订单数据 → 返回200，订单ID
❌ 无效数据 → 返回200，返回0
❌ 空请求 → 返回200，处理空对象
```

#### 支付状态测试
```java
// 测试思路：测试POST /order/havePayed接口
✅ 已支付订单 → 返回200，true
❌ 未支付订单 → 返回200，false
❌ 不存在订单 → 返回200，false
```

#### 用户订单列表测试
```java
// 测试思路：测试POST /order/getAllUserOrder接口
✅ 有效手机号 → 返回200，订单数组
❌ 无效手机号 → 返回200，空数组
❌ 空手机号 → 返回200，空数组
```

#### 订单时间查询测试
```java
// 测试思路：测试GET /order/getOrderTime/{id}接口
✅ 有效订单 → 返回200，LocalDateTime
❌ 不存在订单 → 返回404 Not Found
```

### 🔍 DTO对象处理策略
由于涉及多个DTO对象，采用反射或空对象策略：
```java
private OrderDetailDTO createMockOrderDetailDTO(Integer orderId, String userPhone) {
    OrderDetailDTO dto = new OrderDetailDTO();
    try {
        java.lang.reflect.Field orderIdField = OrderDetailDTO.class.getDeclaredField("orderId");
        orderIdField.setAccessible(true);
        orderIdField.set(dto, orderId);
    } catch (Exception e) {
        System.err.println("反射设置失败: " + e.getMessage());
    }
    return dto;
}
```

---

## 更新后的测试策略总结

### 🎯 完整的测试金字塔
```
            /\
           /  \
          /E2E \     ← IntegrationTest (少量)
         /______\
        /        \
       /   API    \   ← UserControllerTest, CartControllerTest,
      /____________\     FoodControllerTest, BusinessControllerTest,
     /              \    OrderControllerTest (适量)
    /     Unit       \ ← ValidationUtilsTest, EmailServiceTest, 
   \__________________/   UserTest, PerformanceTest (大量)
```

### 📊 控制器测试覆盖
- **UserController**：用户登录、注册、验证码 ✅
- **CartController**：购物车增删改查、验证 ✅
- **FoodController**：商品查询、批量查询 ✅
- **BusinessController**：商家信息查询 ✅
- **OrderController**：订单全生命周期管理 ✅

### 🔧 Lombok问题解决方案
1. **使用Map传递数据**：避免实体类setter方法
2. **反射设置字段**：直接设置私有字段值
3. **空对象策略**：对于复杂DTO，创建空对象进行测试

### 📈 测试质量保证增强
- **完整API覆盖**：所有REST接口都有对应测试
- **边界值全覆盖**：ID边界、数量边界、价格边界等
- **异常场景完整**：所有可能的错误情况都有测试
- **响应格式验证**：确保API响应格式正确

通过这套完整的测试体系，可以确保饿了么外卖系统的质量和稳定性，满足《软件质量保证与测试》课程的学习要求。 